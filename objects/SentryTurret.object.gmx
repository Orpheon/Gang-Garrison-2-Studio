<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>SentryTurretS</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>xoffset = sprite_xoffset-17;
yoffset = sprite_yoffset-10;
refireTime=5;
readyToShoot=false;
noticedTarget=true;
hitDamage=8;
shooting=false;
rotating=false;
nearestTarget = noone;
alarm[0] = refireTime / global.delta_factor;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>{
    readyToShoot = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var targetQueue, testDist, playercheck, targetAngle, obscured, rotateoffset;

if(ownerPlayer.sentry)
{
    x = ownerPlayer.sentry.x;
    y = ownerPlayer.sentry.y;
}
else
{
    instance_destroy();
    exit;
}

if(((direction+270) mod 360)&gt;180) {
    image_xscale=1;
    image_angle = direction;
} else {
    image_xscale=-1;
    image_angle = direction+180;
}

nearestTarget = noone;
targetQueue = ds_priority_create();

// Build a queue of potential targets
with(Character) {
    testDist = distance_to_object(other);
    if(!cloak &amp;&amp; testDist&lt;=375) {
        ds_priority_add(targetQueue, id, testDist);
    }
}

with(Sentry) {
    testDist = distance_to_object(other);
    if(testDist&lt;=375) {
        ds_priority_add(targetQueue, id, testDist);
    }
}

gunSetSolids();
while(!nearestTarget &amp;&amp; !ds_priority_empty(targetQueue)) {
    playercheck = ds_priority_delete_min(targetQueue);
    targetAngle = point_direction(x,y,playercheck.x,playercheck.y);
    if((targetAngle &lt;= 45 || targetAngle &gt;= 315 || (targetAngle &gt;= 135 &amp;&amp; targetAngle &lt;= 225) || place_meeting(x,y,playercheck)) 
        &amp;&amp; playercheck.team != team 
        &amp;&amp; playercheck.hp &gt; 0
        &amp;&amp; !collision_line_bulletblocking(x, y, playercheck.x, playercheck.y)) {
            // Target looks valid, but it might be obscured by a sentry.
            // That has to be tested individually because we have to exclude both this sentry and the target
            // from the collision check
            obscured = false;
            with(Sentry) {
                if(!obscured &amp;&amp; id != other.ownerPlayer.sentry &amp;&amp; id != playercheck &amp;&amp; collision_line(other.x,other.y,playercheck.x,playercheck.y,id,false,false)&gt;=0) {
                    obscured = true;
                }
            }
            if(!obscured) {
                nearestTarget = playercheck;
            }
        }
}
ds_priority_destroy(targetQueue);

if(!nearestTarget) {
    noticedTarget = true;
    if(image_xscale&gt;0)
        direction = 0;
    else
        direction = 180;
        
    if image_xscale != startDirection {
        rotating=true;
    }
} else {
    // set cloaked spy as target if they're in the way
    with(Spy) {
        if(team != other.team &amp;&amp; collision_line(other.x,other.y,other.nearestTarget.x,other.nearestTarget.y,id,true,false)&gt;=0) {
            other.nearestTarget = id;
        }
    }
    
    if(nearestTarget.x &lt; x &amp;&amp; image_xscale == 1) {
        rotating=true;
    } else if(nearestTarget.x &gt; x &amp;&amp; image_xscale == -1) {
        rotating=true;
    }    
        
    if (noticedTarget == true) {
        playsound(x,y,SentryAlert);
        readyToShoot = false;
        alarm[0] = refireTime*2 / global.delta_factor;
    }    
    
    noticedTarget = false;
    
    if(readyToShoot &amp;&amp; (rotating == false)) {
        direction = point_direction(x,y,nearestTarget.x,nearestTarget.y);
        
        // Prevent the turret from turning too high even if it is shooting in that direction.
        // This hides the exception to the angle restriction that occurs when a player is standing
        // directly on the sentry gun. 
        if(direction&gt;=45 and direction&lt;90) direction=45;
        else if(direction&gt;=90 and direction&lt;135) direction=135;
        else if(direction&gt;=225 and direction&lt;270) direction=225;
        else if(direction&gt;=270 and direction&lt;315) direction=315;
        
        playsound(x,y,ShotgunSnd);
        ownerPlayer.sentry.idleTimer = false;
        ownerPlayer.sentry.alarm[5] = 30 / global.delta_factor;
        
        if(nearestTarget.ubered == 0) {
            damageAuto(ownerPlayer, nearestTarget, hitDamage);
            if (nearestTarget.lastDamageDealer != ownerPlayer &amp;&amp; object_is_ancestor(nearestTarget.object_index, Character)) {
                if (nearestTarget.lastDamageDealer != nearestTarget.player){
                    nearestTarget.secondToLastDamageDealer = nearestTarget.lastDamageDealer;
                    nearestTarget.alarm[4] = nearestTarget.alarm[3];
                }
            }
            nearestTarget.alarm[3] = ASSIST_TIME / global.delta_factor;
            nearestTarget.lastDamageDealer = ownerPlayer;
            nearestTarget.lastDamageSource = global.DAMAGE_SOURCE_SENTRYTURRET;
            if(global.gibLevel &gt; 0 and object_is_ancestor(nearestTarget.object_index, Character))
            {
                blood = instance_create(nearestTarget.x,nearestTarget.y,Blood);
                blood.direction = direction-180;
                dealFlicker(nearestTarget);
            }
        }
        shooting=true;
        readyToShoot=false;
        alarm[0]=refireTime / global.delta_factor;
    }
}
gunUnsetSolids();

if(rotating) {
    rotateindex += 0.3 * global.delta_factor;
    if(rotateindex &gt;= rotateend) {
        image_xscale = -image_xscale;
        direction += 180;
        rotating = false;
        rotateindex = rotatestart;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (startDirection &gt; 0) {
    direction=0;
} else {
    direction=180;
}

if(team == TEAM_RED) {
    rotateoffset=0;
} else {
    rotateoffset=5;
}

rotatestart = rotateoffset;
rotateend = rotateoffset+4;
rotateindex = rotatestart;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (distance_to_point(view_xview + view_wview/2, view_yview + view_hview/2) &gt; 800)
    exit;
    
var imageOffset;
if(shooting)
{
    shooting=false;
    imageOffset=2;
    if(instance_exists(nearestTarget))
    {
        xshootoffset=4*image_xscale;
        draw_set_alpha(0.6);
        draw_line_width_color(x+lengthdir_x(10,direction)-xshootoffset,y+lengthdir_y(10,direction)-2,nearestTarget.x+random(25)-12,nearestTarget.y+random(25)-12,2,c_yellow,c_black);
    }
}
else
    imageOffset=0;
    
if(ownerPlayer.sentry)
{
    if(ownerPlayer.sentry.image_index &gt; 7)
    {
        if(rotating)
            draw_sprite_ext(TurretRotateS,round(rotateindex),x,y,image_xscale,image_yscale,0,c_white,1);
        else
            draw_sprite_ext(sprite_index,ownerPlayer.team + imageOffset,round(x+xoffset*image_xscale),round(y+yoffset),image_xscale,image_yscale,image_angle,c_white,1);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
