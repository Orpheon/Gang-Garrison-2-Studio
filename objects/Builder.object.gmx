<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-110001</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Presets
metadata = ds_map_create();
ds_map_add(metadata, "type", "meta");
ds_map_add(metadata, "background", "ffffff");
ds_map_add(metadata, "void", "000000");

unloadResources();
newProperties = ds_map_create();

// Window logic
tooltipIdx = -1;
expanded = 1;
expandIdx = 1;
canClick = true;

entityButtonSize = 28;
buttonWidth = 115;
headerWidth = 122;
buttonHeight = 17;
buttonSpriteWidth = 17;
layerHeight = 80;
layerWidth = 160;

vItems = 5; // entity menu (rowsize)
entityButtonCount = 0;
items = 5;  // button menu default
oldItems = items;
height = items*buttonHeight;
dragHeight = 0;
scrollIndex = 0;
layerName = "BG";
layerIndex = 7;

holdHeader[0] = false;
holdHeader[1] = false;
holdHeader[2] = false;
holdX = -1;
holdY = -1;

startX[0] = 0;
startX[1] = 0; // Also gets set in event_user(0)
startX[2] = 0;
startY[1] = 0;
startY[2] = 0;

// Builder logic
erasing = false;
scaling = false;
dragging = false;
snapScaling = false;
scaleLock = true;
showWM = false;
showGrid = false;
setOffsets = false;
scaleX = -1;
scaleY = -1;
entityScale = 1;
moveSpeed = 32;
mapBG = "";
mapWM = "";
wmString = "";

// vars for displaying the selected entity
spriteWidth = -1;
spriteHeight = -1;
spriteCenterX = -1;
spriteCenterY = -1;
spriteOffsetX = -1;
spriteOffsetY = -1;
mirroredCenterX = -1;
mirroredOffsetX = -1;
selected = -1;
selectedSprite = -1;
selectedImage = -1;
selectedProperties = -1;
mirrored = -1;
mirroredSprite = -1;
mirroredImage = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (metatadata != -1) ds_map_destroy(metadata);
ds_map_destroy(newProperties);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!visible) exit;

var i, button, xOfsset, yOffset, ySize, xSize;
xOffset = view_xview[0] + startX[0];
ySize = view_hview[0];
yOffset = view_yview[0] + ySize;
xSize = view_wview[0];
canClick = true;
tooltipIdx = -1;

if (instance_exists(MenuController) || mouse_x &gt; view_xview[0]+view_wview[0] || mouse_x &lt; view_xview[0] || mouse_y &gt; view_yview[0]+view_hview[0] || mouse_y &lt; view_yview[0]) canClick = false;
else {
    if (keyboard_check(global.left) || keyboard_check(global.left2)) {
        view_xview[0] -= moveSpeed*global.delta_factor;
        event_user(1);
    } else if (keyboard_check(global.right) || keyboard_check(global.right2)) {
        view_xview[0] += moveSpeed*global.delta_factor;
        event_user(1);
    } 
    if (keyboard_check(global.jump) || keyboard_check(global.jump2)) {
        view_yview[0] -= moveSpeed*global.delta_factor;
        event_user(1);
    } else if (keyboard_check(global.down) || keyboard_check(global.down2)) {
        view_yview[0] += moveSpeed*global.delta_factor;
        event_user(1);
    }
    
    if (setOffsets &amp;&amp; layerIndex &lt; 7) {
        if (background_visible[layerIndex]) {
            selected = -1;
            mirrored = -1;
            if (dragging) {
                ParallaxController.background_xfactor[layerIndex] = max(0, min(10, ParallaxController.background_xfactor[layerIndex]-(holdX-mouse_x)/100));
                ParallaxController.background_yfactor[layerIndex] = max(0, min(10, ParallaxController.background_yfactor[layerIndex]+(holdY-mouse_y)/100));
                holdX = mouse_x;
                holdY = mouse_y;
                if (!mouse_check_button(mb_left))
                    dragging = false;
            } else if (mouse_check_button_pressed(mb_left)) {
                holdX = mouse_x;
                holdY = mouse_y;
                dragging = true;
            } else if (mouse_check_button_pressed(mb_right)) {
                dragging = false;
                setOffsets = false;
            }
        } else
            dragging = false;
    } else
        dragging = false;
}

if (expanded) {
    expandIdx = max(0, expandIdx - 0.05*global.delta_factor);
    
    if (expandIdx != 0 &amp;&amp; expanded) {
        height = items*buttonHeight * sqrt(1-expandIdx*0.93);
        dragHeight = height;
    } else height = items*buttonHeight;
    
    if (holdHeader[0]) {
        if (toggleHeader &amp;&amp; (abs(holdX-mouse_x) &gt; 3 || abs(holdY-mouse_y) &gt; 3)) toggleHeader = false;
        else if (!toggleHeader) {
            startX[0] += mouse_x-holdX;
            startX[0] = min(xSize-headerWidth, max(0, startX[0]));
            holdX = mouse_x;
            
            dragHeight -= mouse_y-holdY;
            holdY = mouse_y;
            dragHeight = min(ySize, max(buttonHeight, dragHeight));
            items = min(ceil(dragHeight/buttonHeight), ds_list_size(global.buttons));
            height = items*buttonHeight;
        }
        
        if (!mouse_check_button(mb_left)) {
            holdHeader[0] = false;
            if (toggleHeader) {
                expanded = !expanded;
                oldItems = items;
            }
        }
    } else if (!holdHeader[1] &amp;&amp; !holdHeader[2]) {
        dragHeight = max(height, dragHeight - max(2, (dragHeight-height)/16)*global.delta_factor);
    
        if (mouse_x &gt; xOffset &amp;&amp; mouse_x &lt; xOffset+buttonWidth) {
            if (mouse_y &gt; yOffset-dragHeight-buttonHeight &amp;&amp; mouse_y &lt; yOffset-dragHeight) {
                canClick = false;
                if (mouse_check_button_pressed(mb_left)) {
                    holdHeader[0] = true;
                    toggleHeader = true;
                    holdX = mouse_x;
                    holdY = mouse_y;
                    canClick = false;
                }
            } else if (mouse_y &gt; yOffset-height) {
                canClick = false;
                if (mouse_check_button_pressed(mb_left)) {
                    button = items - 1 - floor((yOffset-mouse_y)/height*items) + scrollIndex;
                    if (!buttons[button, TOGGLE]) {
                        execute_string(ds_map_find_value(ds_list_find_value(global.buttons, button), "code"), true);
                    } else {
                        buttons[button, TOGGLED] = execute_string(ds_map_find_value(ds_list_find_value(global.buttons, button), "code"), !buttons[button, TOGGLED]);
                    }
                }
            }
        } else if (mouse_x &gt; xOffset+buttonWidth &amp;&amp; mouse_x &lt; xOffset+headerWidth) {
            if (mouse_y &gt; yOffset-height) {
                if (mouse_check_button(mb_left)) scrollIndex = floor((1-(yOffset-mouse_y)/height)*(ds_list_size(global.buttons)-items));
                canClick = false;
            }
        }
    }
    
    if (!canClick) {
        if (mouse_wheel_up()) scrollIndex -= 1;
        else if (mouse_wheel_down()) scrollIndex += 1;
    }
    scrollIndex = max(0, min(ds_list_size(global.buttons)-floor(height/buttonHeight), scrollIndex));
} else {
    expandIdx = min(1, expandIdx + 0.05*global.delta_factor);
    height *= sqrt(1-expandIdx*0.93);
    dragHeight = height;
    items = min(ds_list_size(global.buttons), ceil(height/buttonHeight));
    
    if (mouse_x &gt; xOffset &amp;&amp; mouse_x &lt; xOffset+buttonWidth) {
        if (mouse_y &gt; yOffset-dragHeight-buttonHeight &amp;&amp; mouse_y &lt; yOffset-dragHeight) {
            if (mouse_check_button_pressed(mb_left)) {
                expanded = true;
                items = oldItems;
                canClick = false;
            }
        }
    }
}

// Not hovering over the button menu
if (canClick &amp;&amp; !holdHeader[0] &amp;&amp; !holdHeader[2]) {
    xOffset = view_xview[0] + startX[1];
    yOffset = view_yview[0] + startY[1];
    
    if (holdHeader[1]) {
        startX[1] += mouse_x-holdX;
        startX[1] = min(xSize-entityButtonSize*vItems-1, max(1, startX[1]));
        holdX = mouse_x;
        
        startY[1] += mouse_y-holdY;
        startY[1] = min(ySize-2*entityButtonSize-1, max(0, startY[1]));
        holdY = mouse_y;
        
        if (!mouse_check_button(mb_left)) holdHeader[1] = false;
    } else if (mouse_x &gt; xOffset &amp;&amp; mouse_x &lt; xOffset+entityButtonSize*vItems) {
        if (mouse_y &gt; yOffset+buttonHeight &amp;&amp; mouse_y &lt; yOffset+buttonHeight+entityButtonSize*ceil(entityButtonCount/vItems)) {
            i = floor((mouse_x-xOffset)/entityButtonSize) + floor((mouse_y-yOffset-buttonHeight)/entityButtonSize)*vItems;
            canClick = false;
            if (i &lt; entityButtonCount) {
                tooltipIdx = i;
                if (mouse_check_button_pressed(mb_left)) {
                    if (selected != i) {
                        selected = i;
                        event_user(2);
                    }
                } else if (mouse_check_button_pressed(mb_right)) {
                    if (selected != i) {
                        selected = i;
                        event_user(2);
                    }
                    showPropertyMenu(selectedProperties, newProperties);
                    event_user(3);
                }
            }
        } else if (mouse_y &gt; yOffset &amp;&amp; mouse_y &lt; yOffset+buttonHeight) {
            canClick = false;
            if (mouse_check_button_pressed(mb_left)) {
                holdHeader[1] = true;
                holdX = mouse_x;
                holdY = mouse_y;
            }
        }
    }
}

// Not hovering above the button menu or the entity menu
if (canClick &amp;&amp; !holdHeader[0] &amp;&amp; !holdHeader[1]) {
    xOffset = view_xview[0] + startX[2];
    yOffset = view_yview[0] + startY[2];
    
    if (holdHeader[2]) {
        canClick = false;
        startX[2] += mouse_x-holdX;
        startX[2] = min(xSize-layerWidth-1, max(1, startX[2]));
        holdX = mouse_x;
        
        startY[2] += mouse_y-holdY;
        startY[2] = min(ySize-layerHeight-buttonHeight-1, max(0, startY[2]));
        holdY = mouse_y;
        
        if (!mouse_check_button(mb_left)) holdHeader[2] = false;
    } else if (mouse_x &gt; xOffset &amp;&amp; mouse_x &lt; xOffset+layerWidth) {
        if (mouse_x &lt; xOffset+23) {
            if (mouse_y &gt; yOffset+buttonHeight+3 &amp;&amp;  mouse_y &lt; yOffset+buttonHeight+23) {
                canClick = false;
                if (mouse_check_button_pressed(mb_left) &amp;&amp; layerIndex&gt;0) // up
                    layerIndex-=1;
            } else if (mouse_y &gt; yOffset+buttonHeight-23+layerHeight &amp;&amp; mouse_y &lt; yOffset+buttonHeight-3+layerHeight) {
                canClick = false;
                if (mouse_check_button_pressed(mb_left) &amp;&amp; layerIndex&lt;8) // down
                    layerIndex+=1;
            }          
        } else if (mouse_y &gt; yOffset+buttonHeight-23+layerHeight &amp;&amp; mouse_y &lt; yOffset+buttonHeight-3+layerHeight) {
             if (mouse_x &gt; xOffset+27 &amp;&amp; mouse_x &lt; xOffset+90) {
                canClick = false;
                if (mouse_check_button_pressed(mb_left)) {  // Clear
                    if (layerIndex == 8 &amp;&amp; instance_exists(ParallaxController)) {
                        if (ParallaxController.foreground != -1) {
                            background_delete(ParallaxController.foreground);
                            ds_map_delete(Builder.metadata, "bg_foreground");
                            ParallaxController.foreground = -1;
                        }
                    } else if (layerIndex != 7 &amp;&amp; ds_map_find_value(global.resources, "bg_layer" + string(layerIndex)) &gt; 0) {
                        background_delete(ds_map_find_value(global.resources, "bg_layer" + string(layerIndex)));
                        ds_map_delete(global.resources, "bg_layer" + string(layerIndex));
                        ds_map_delete(Builder.metadata, "bg_layer" + string(layerIndex));
                        background_visible[layerIndex] = 0;
                    }
                }
             } else if (mouse_x &gt; xOffset+97 &amp;&amp; mouse_x &lt; xOffset+157) {
                canClick = false;
                if (mouse_check_button_pressed(mb_left)) { // Offsets
                    // Save all offsets if we were editting them
                    if (setOffsets &amp;&amp; instance_exists(ParallaxController)) {
                        for(i=0;i&lt;7;i+=1){
                            if (background_visible[i]) {
                                if (is_string(ds_map_find_value(Builder.metadata, "layer" + string(i) + "xfactor")))
                                    ds_map_replace(Builder.metadata, "layer" + string(i) + "xfactor", string(ParallaxController.background_xfactor[i]));
                                else
                                    ds_map_add(Builder.metadata, "layer" + string(i) + "xfactor", string(ParallaxController.background_xfactor[i]));
                                if (is_string(ds_map_find_value(Builder.metadata, "layer" + string(i) + "yfactor")))
                                    ds_map_replace(Builder.metadata, "layer" + string(i) + "yfactor", string(ParallaxController.background_yfactor[i]));
                                else
                                    ds_map_add(Builder.metadata, "layer" + string(i) + "yfactor", string(ParallaxController.background_yfactor[i]));
                            }
                        }                        
                    }
                    setOffsets = !setOffsets;
                }
             }
        } else if (mouse_y &gt; yOffset &amp;&amp; mouse_y &lt; yOffset+buttonHeight) {
            canClick = false;
            if (mouse_check_button_pressed(mb_left)) {
                holdHeader[2] = true;
                holdX = mouse_x;
                holdY = mouse_y;
            }
        } else if (mouse_y &lt; yOffset+buttonHeight+layerHeight &amp;&amp; mouse_y &gt; yOffset+buttonHeight) {
            canClick = false;
            if (mouse_check_button_pressed(mb_left)) { // new resource
                var resource;
                resource = get_open_filename("Resource (PNG, GIF)|*.png;*.gif;","");
                if (resource == "")
                    break;
                if (layerIndex == 8) {
                    ds_map_delete(Builder.metadata, "bg_foreground");
                    ds_map_add(Builder.metadata, "bg_foreground", resourceToString(resource));
                } else if (layerIndex == 7) {
                    Builder.mapBG = resource;
                    background_replace(BuilderBGB, resource, false, false);
                    background_xscale[7] = 6;
                    background_yscale[7] = 6;
                } else {
                    ds_map_delete(Builder.metadata, "bg_layer" + string(layerIndex));
                    ds_map_add(Builder.metadata, "bg_layer"+string(layerIndex), resourceToString(resource));
                }
                loadMetadata(Builder.metadata, true);
            }
            
            if (mouse_wheel_up() &amp;&amp; layerIndex&gt;0) layerIndex -= 1;
            else if (mouse_wheel_down() &amp;&amp; layerIndex&lt;8) layerIndex += 1;
        }
    }
    
    // Update the layername
    switch(layerIndex) {
        case 8: layerName = "FG"; break;
        case 7: layerName = "BG"; break;
        default: layerName = "L" + string(layerIndex+1);                
    }
}

// Not hovering over any menus
if (canClick) {
    if (mouse_check_button_pressed(mb_left) &amp;&amp; selected != -1) {
        scaling = true;
        scaleX = round(mouse_x/6)*6;
        scaleY = round(mouse_y/6)*6;
        scaleLock = true;
    } else if (mouse_check_button_pressed(mb_right)) {
        scaling = false;
        erasing = true;
        scaleX = round(mouse_x/6)*6;
        scaleY = round(mouse_y/6)*6;
        selected = -1;
        mirrored = -1;
    }
}

// Fill in the selected area if the users stops scaling.
if ((mouse_check_button_released(mb_left) || !scale) &amp;&amp; scaling) {
    scaling = false;
    if (scale &amp;&amp; entityButtons[selected, SCALE] &amp;&amp; !scaleLock) {
        var entity, entity2, xscale, yscale, _x, _y;
        _x = max(scaleX+6, round(mouse_x/6)*6+spriteCenterX);
        _y = max(scaleY+6, round(mouse_y/6)*6+spriteCenterY);
        xscale = (_x-scaleX) / spriteWidth;
        yscale = (_y-scaleY) / spriteHeight;
        placeEntity(scaleX-spriteCenterX+spriteOffsetX*xscale, scaleY-spriteCenterY+spriteOffsetY*yscale, xscale, yscale);        
        if (symmetry) 
            placeEntity(map_width()-scaleX+spriteCenterX+spriteOffsetX*xscale-(_x-scaleX), scaleY-spriteCenterY+spriteOffsetY*yscale, xscale, yscale, true);
    } else {
        var _x, _y, i, j, entity, entity2;
        _x = max(spriteWidth+scaleX, scaleX+ceil((mouse_x-scaleX)/spriteWidth)*spriteWidth);
        _y = max(spriteHeight+scaleY, scaleY+ceil((mouse_y-scaleY)/spriteHeight)*spriteHeight);

        for(i=scaleX-spriteCenterX; i+spriteCenterX&lt;_x; i+=spriteWidth) {      
            for(j=scaleY-spriteCenterY; j+spriteCenterY&lt;_y; j+=spriteHeight) {
                placeEntity(i+spriteOffsetX, j+spriteOffsetY, entityScale, entityScale);    
                if (symmetry)    
                    placeEntity(map_width()-i+mirroredOffsetX, j+spriteOffsetY, entityScale, entityScale, true);               
            }
        }
    }
} else if ((mouse_check_button_released(mb_right)) &amp;&amp; erasing) {
    erasing = false;

    with(LevelEntity)
        if (collision_rectangle(other.scaleX, other.scaleY, mouse_x, mouse_y, id, false, false))
            instance_destroy();
    
    if (symmetry) {
        var _x;
        scaleX = map_width() - scaleX;
        _x = map_width() - mouse_x;

        with(LevelEntity)
            if (collision_rectangle(other.scaleX, other.scaleY, _x, mouse_y, id, false, false))
                instance_destroy();
    } 
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// Look for new resources

var resource, sprite, resourceString;
resource = ds_map_find_value(newProperties, "resource");
sprite = -1;

if (is_string(resource) &amp;&amp; Builder.metadata != -1)
{
    sprite = ds_map_find_value(global.resources, resource);
    if (sprite &lt;= 0)
    {
        resourceString = ds_map_find_value(Builder.metadata, resource);
        if (is_string(resourceString))
        {
            sprite = stringToResource(resourceString);
            ds_map_add(global.resources, resource, sprite);
        }
    }
    
    if (sprite &gt; 0)
    {
        entityScale = max(1, readProperty(newProperties, "scale", REAL, 1));
        
        selectedSprite = sprite;
        selectedImage = 0;
        
        spriteWidth = sprite_get_width(selectedSprite)*entityScale;
        spriteHeight = sprite_get_height(selectedSprite)*entityScale;
        spriteCenterX = round(sprite_get_width(selectedSprite)*entityScale/12)*6;
        spriteCenterY = round(sprite_get_height(selectedSprite)*entityScale/12)*6;
        spriteOffsetX = sprite_get_xoffset(selectedSprite)*entityScale;
        spriteOffsetY = sprite_get_yoffset(selectedSprite)*entityScale;
        
        // Mirrored offsets, they have to be used because the ones above are rounded
        mirroredCenterX = -spriteCenterX;
        mirroredOffsetX = spriteOffsetX - sprite_get_width(selectedSprite)*entityScale;
        
        // Mirrored entities have the same sprite
        mirroredSprite = sprite;
        mirroredImage = 0;
    }
    else 
        event_user(2);  // Reset
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// change preview image etc when a new entity is selected.

button = ds_list_find_value(global.entityData, entityButtons[selected, INDEX]);
selectedSprite = ds_map_find_value(button, "entity_sprite");
selectedImage = ds_map_find_value(button, "entity_image");
selectedProperties = ds_map_find_value(button, "properties");
ds_map_clear(newProperties);

spriteWidth = sprite_get_width(selectedSprite);
spriteHeight = sprite_get_height(selectedSprite)
spriteCenterX = round(sprite_get_width(selectedSprite)/12)*6;
spriteCenterY = round(sprite_get_height(selectedSprite)/12)*6;
spriteOffsetX = sprite_get_xoffset(selectedSprite);
spriteOffsetY = sprite_get_yoffset(selectedSprite);
entityScale = 1;

//Mirrored offsets, they have to be used because the ones above are rounded
mirroredCenterX = -spriteCenterX;
mirroredOffsetX = spriteOffsetX - sprite_get_width(selectedSprite);

// Mirror entities and invert their behaviour if possible
var name, data;
name = mirrorEntity(ds_list_find_value(global.entities, entityButtons[selected, INDEX]));
data = getEntityData(name);
if (data == -1) mirrored = -1;
else {
    mirrored = ds_list_find_index(global.entities, name);
    mirroredSprite = ds_map_find_value(data, "entity_sprite");
    mirroredImage = ds_map_find_value(data, "entity_image");
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Ensure we don't scroll past the edges of the level
if(view_yview[0] &gt; 6 * background_get_height(BuilderBGB) - view_hview[0]) view_yview[0] = 6 * background_get_height(BuilderBGB) - view_hview[0];
if(view_xview[0] &gt; 6 * background_get_width(BuilderBGB) - view_wview[0]) view_xview[0] = 6 * background_get_width(BuilderBGB) - view_wview[0];
if(view_yview[0] &lt; 0) view_yview[0] = 0;
if(view_xview[0] &lt; 0) view_xview[0] = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>TOGGLE = 0;
TOGGLED = 1;
TEXT = 2;

TOOLTIP = 0;
TOGGLED = 1;
SPRITE = 2;
IMAGE = 3;
INDEX = 4;
SCALE = 5;

var i, button, j, properties;
for(i=0; i&lt;ds_list_size(global.buttons); i+=1) {
    button = ds_list_find_value(global.buttons, i);
    buttons[i, TOGGLE] = ds_map_find_value(button, "toggle");
    buttons[i, TOGGLED] = ds_map_find_value(button, "active");
    buttons[i, TEXT] = ds_map_find_value(button, "name");
}

j=0;
for(i=0; i&lt;ds_list_size(global.entities); i+=1) {
    button = ds_list_find_value(global.entityData, i);
    if (ds_map_find_value(button, "gamemode") != 0 &amp;&amp; (ds_map_find_value(button, "gamemode") == -1 || (ds_map_find_value(button, "gamemode") &amp; gamemode) &gt; 0 || gamemode == 1)) {
        entityButtons[j, TOGGLED] = false;
        entityButtons[j, SPRITE] = ds_map_find_value(button, "button_sprite");
        entityButtons[j, IMAGE] = ds_map_find_value(button, "button_image");
        entityButtons[j, TOOLTIP] = ds_map_find_value(button, "tooltip");
        entityButtons[j, INDEX] = i;
        
        properties = ds_map_find_value(button, "properties");
        entityButtons[j, SCALE] = (is_string(ds_map_find_value(properties, "xscale")) &amp;&amp; is_string(ds_map_find_value(properties, "yscale")));
        j+=1;
    }
}

entityButtonCount = j;
resetToggles();
startX[1] = view_wview[0] - vItems*entityButtonSize - 1;
startX[2] = view_wview[0] - layerWidth - 1;
startY[2] = view_hview[0] - layerHeight - buttonHeight - 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i, j, button, xOfsset, yOffset, _y, scrollHeight, sectionHeight, xr, yr;
xr = round(mouse_x/6)*6;
yr = round(mouse_y/6)*6
draw_set_alpha(1);
draw_set_valign(fa_left);
draw_set_halign(fa_top);

// Draw the wallmask
if (showWM)
    draw_background_ext(BuilderWMB, 0, 0, 6, 6, 0, c_white, 1);

// Draw the grid (draw_sprite_tiled and draw_background_tiled both crash the game because the room is too big, so do it manually)
if (showGrid) {
    xOffset = floor(view_xview[0]/12)*12;
    yOffset = floor(view_yview[0]/12)*12;
    for(i=0;i&lt;=view_wview[0]/12;i+=1) {
        for(j=0;j&lt;view_hview[0]/12+12;j+=1) {
            draw_sprite(GridS, 0, xOffset+i*12, yOffset+j*12);
        }
    }
}

//********** OFFSET MARKERS **********\\
if (setOffsets) {
    draw_sprite(SpectatorCrosshairS, 1, map_width()/2, map_height()/2);
    if (layerIndex &lt; 7) {
        if (background_visible[layerIndex]) {
            draw_sprite(SpectatorCrosshairS, 0, map_width()/2 + round(background_x[layerIndex]), map_height()/2 + round(background_y[layerIndex]));
            draw_set_color(make_color_rgb(159, 159, 159));
            draw_rectangle(round(mouse_x)+10, round(mouse_y)+10, round(mouse_x)+75, round(mouse_y)+43, false);
            draw_set_color(make_color_rgb(63, 63, 63));
            draw_rectangle(round(mouse_x)+10, round(mouse_y)+10, round(mouse_x)+75, round(mouse_y)+43, true);
            draw_text(round(mouse_x)+13, round(mouse_y)+13, "X: " + string(ParallaxController.background_xfactor[layerIndex]));
            draw_text(round(mouse_x)+13, round(mouse_y)+30, "Y: " + string(ParallaxController.background_yfactor[layerIndex]));
        }
    }
}

//********** SELECTED ENTITY **********\\
if (canClick &amp;&amp; selected != -1) {   
    if (!scaling || entityButtons[selected, SCALE]) {
        // Scaled preview
        var _x, _y, xscale, yscale;
        
        // Unlock scaling if the user moves their mouse
        if (scaleLock &amp;&amp; (abs(mouse_x-scaleX) &gt; 3 || abs(mouse_y-scaleY) &gt; 3))
            scaleLock = false;
            
        if (!scaling || scaleLock) {
            scaleX = xr;
            scaleY = yr;
            _x = xr + spriteWidth;
            _y = yr + spriteHeight;
        } else {
            _x = max(scaleX+6, xr+spriteCenterX);
            _y = max(scaleY+6, yr+spriteCenterY);
        }
        if (entityScale == 1) {
            xscale = (_x-scaleX) / spriteWidth;
            yscale = (_y-scaleY) / spriteHeight;
        } else {
            xscale = entityScale;
            yscale = entityScale;
        }
        
        draw_sprite_ext(selectedSprite, selectedImage, scaleX-spriteCenterX+spriteOffsetX*xscale, scaleY-spriteCenterY+spriteOffsetY*yscale, xscale, yscale, 0, c_white, 0.8);
        if (symmetry &amp;&amp; mirrored != -1) draw_sprite_ext(mirroredSprite, mirroredImage, map_width()-scaleX-mirroredCenterX+spriteOffsetX*xscale-(_x-scaleX), scaleY-spriteCenterY+spriteOffsetY*yscale, xscale, yscale, 0, c_white, 0.4);
    } else {
        // Tiled preview 
        var _x, _y, i, j; 
        _x = scaleX + max(spriteWidth, ceil((mouse_x-scaleX)/spriteWidth)*spriteWidth);
        _y = scaleY + max(spriteHeight, ceil((mouse_y-scaleY)/spriteHeight)*spriteHeight);
        for(i=scaleX-spriteCenterX; i+spriteCenterX&lt;_x; i+=spriteWidth) {      
            for(j=scaleY-spriteCenterY; j+spriteCenterY&lt;_y; j+=spriteHeight) {
                draw_sprite_ext(selectedSprite, selectedImage, i+spriteOffsetX, j+spriteOffsetY, entityScale, entityScale, 0, c_white, 0.8);
                if (symmetry &amp;&amp; mirrored != -1) draw_sprite_ext(mirroredSprite, mirroredImage, map_width()-i+mirroredOffsetX, j+spriteOffsetY, entityScale, entityScale, 0, c_white, 0.4);
            }
        }
    }
    
    // Rectangle showing the selected area
    draw_set_color(c_green);
    draw_rectangle(scaleX-spriteCenterX, scaleY-spriteCenterY, _x-spriteCenterX, _y-spriteCenterY, true);
    draw_set_color(c_red);
    if (symmetry &amp;&amp; mirrored != -1) draw_rectangle(map_width()-scaleX-mirroredCenterX, scaleY-spriteCenterY, map_width()-_x-mirroredCenterX, _y-spriteCenterY, true);
} else if (canClick &amp;&amp; erasing) {
    draw_set_color(c_green);
    draw_rectangle(scaleX, scaleY, xr, yr, true);
    draw_set_alpha(0.2);
    draw_rectangle(scaleX, scaleY, xr, yr, false);
    
    if (symmetry) {
        draw_set_color(c_red);
        draw_set_alpha(0.5);
        draw_rectangle(map_width()-scaleX, scaleY, map_width()-xr, yr, true);
        draw_set_alpha(0.1);
        draw_rectangle(map_width()-scaleX, scaleY, map_width()-xr, yr, false);
    }
    draw_set_alpha(1);
}

//********** BUTTON MENU **********\\
xOffset = view_xview[0] + startX[0];
yOffset = view_yview[0] + view_hview[0];

if (expanded || expandIdx &lt; 1) {
    // Background
    draw_set_color(make_color_rgb(159, 159, 159));
    draw_rectangle(xOffset, yOffset-dragHeight, xOffset+headerWidth, yOffset, false);
    draw_set_color(make_color_rgb(63, 63, 63));
    draw_rectangle(xOffset, yOffset-dragHeight, xOffset+headerWidth, yOffset, true);
    
    // Scrollbar
    sectionHeight = max(2, items / ds_list_size(global.buttons) * (height-5));
    if (ds_list_size(global.buttons) == items) scrollHeight = 0;
    else scrollHeight = ((height-5) - sectionHeight) / (ds_list_size(global.buttons)-items);
    draw_rectangle(xOffset+buttonWidth+1, yOffset-height+2+scrollHeight*scrollIndex, xOffset+headerWidth-2, yOffset-height+2+sectionHeight+scrollHeight*scrollIndex, false);
    
    // Buttons
    for(i=0; i&lt;items; i+=1) {
        if (expandIdx != 0 &amp;&amp; expanded) _y = yOffset-i*buttonHeight*sqrt(1-expandIdx*0.93);
        else _y = yOffset-i*buttonHeight;
        button = items - 1 - i + scrollIndex;
        draw_sprite_ext(gbButtonS, 0+buttons[button, TOGGLED]*3, xOffset, _y-buttonHeight, 1, 1, 0, c_white, 1);
        draw_sprite_ext(gbButtonS, 1+buttons[button, TOGGLED]*3, xOffset+buttonSpriteWidth, _y-buttonHeight, buttonWidth/buttonSpriteWidth-2, 1, 0, c_white, 1);
        draw_sprite_ext(gbButtonS, 2+buttons[button, TOGGLED]*3, xOffset-buttonSpriteWidth+buttonWidth, _y-buttonHeight, 1, 1, 0, c_white, 1);
        draw_text(xOffset+2, _y-buttonHeight+3, string(buttons[button, TEXT]));
    }
}
draw_sprite_ext(gbMenuLayoutS, 0, xOffset, yOffset - (dragHeight+buttonHeight), 1, 1, 0, c_white, 1);
draw_sprite_ext(gbMenuLayoutS, 1, xOffset+buttonSpriteWidth, yOffset - (dragHeight+buttonHeight), headerWidth/(buttonSpriteWidth-1)-2, 1, 0, c_white, 1);
draw_sprite_ext(gbMenuLayoutS, 2, xOffset-buttonSpriteWidth+headerWidth+1, yOffset - (dragHeight+buttonHeight), 1, 1, 0, c_white, 1);

//********** LAYER MENU **********\\
xOffset = view_xview[0] + startX[2];
yOffset = view_yview[0] + startY[2];

draw_sprite_ext(gbMenuLayoutS, 0, xOffset, yOffset, 1, 1, 0, c_white, 1);
draw_sprite_ext(gbMenuLayoutS, 1, xOffset+buttonSpriteWidth, yOffset, layerWidth/(buttonSpriteWidth-1)-2, 1, 0, c_white, 1);
draw_sprite_ext(gbMenuLayoutS, 2, xOffset-buttonSpriteWidth+layerWidth+1, yOffset, 1, 1, 0, c_white, 1);

// Background
draw_set_color(make_color_rgb(159, 159, 159));
draw_rectangle(xOffset, yOffset+buttonHeight, xOffset+layerWidth, yOffset+layerHeight+buttonHeight, false);
draw_set_color(make_color_rgb(63, 63, 63));
draw_rectangle(xOffset, yOffset+buttonHeight, xOffset+layerWidth, yOffset+layerHeight+buttonHeight, true);

// Scrollbuttons
draw_rectangle(xOffset+3, yOffset+buttonHeight+3, xOffset+23, yOffset+buttonHeight+23, (layerIndex&gt;0));
if (layerIndex &gt; 0)
    draw_sprite(ScrollButtonS, 0, xOffset+13, yOffset+buttonHeight+13);
draw_rectangle(xOffset+3, yOffset+buttonHeight-3+layerHeight, xOffset+23, yOffset+buttonHeight-23+layerHeight, (layerIndex&lt;8));
if (layerIndex &lt; 8)
    draw_sprite(ScrollButtonS, 1, xOffset+13, yOffset+buttonHeight-13+layerHeight);

// Clear &amp; offsets button
draw_rectangle(xOffset+27, yOffset+buttonHeight-3+layerHeight, xOffset+90, yOffset+buttonHeight-23+layerHeight, true);
draw_rectangle(xOffset+97, yOffset+buttonHeight-3+layerHeight, xOffset+157, yOffset+buttonHeight-23+layerHeight, true);

// Text
draw_text(xOffset+40, yOffset+buttonHeight-18+layerHeight, "Clear");
if (!setOffsets)
    draw_text(xOffset+100, yOffset+buttonHeight-18+layerHeight, "Offsets");
else
    draw_text(xOffset+110, yOffset+buttonHeight-18+layerHeight, "Save");
draw_text(xOffset+6, yOffset+buttonHeight + 35, layerName);

// Layer preview
var bgScale, bg;
bgScale = 131/background_get_width(BuilderBGB);
if (bgScale &gt; 51/background_get_height(BuilderBGB))
    bgScale = 51/background_get_height(BuilderBGB);

bg = -1;
if (layerIndex == 8 &amp;&amp; instance_exists(ParallaxController))
    bg = ParallaxController.foreground;
else if (background_visible[layerIndex])
    bg = background_index[layerIndex];
if (bg &gt; 0)
    draw_background_ext(bg, xOffset+27, yOffset+buttonHeight+3, bgScale, bgScale, 0, c_white, 1);
else
    draw_rectangle(xOffset+27, yOffset+buttonHeight+3, xOffset+154, yOffset+buttonHeight+54, false);

//********** ENITITY MENU  **********\\
xOffset = view_xview[0] + startX[1];
yOffset = view_yview[0] + startY[1];

draw_sprite_ext(gbMenuLayoutS, 0, xOffset, yOffset, 1, 1, 0, c_white, 1);
draw_sprite_ext(gbMenuLayoutS, 1, xOffset+buttonSpriteWidth, yOffset, entityButtonSize*vItems/(buttonSpriteWidth-1)-2, 1, 0, c_white, 1);
draw_sprite_ext(gbMenuLayoutS, 2, xOffset-buttonSpriteWidth+entityButtonSize*vItems+1, yOffset, 1, 1, 0, c_white, 1);

// Background
draw_set_color(make_color_rgb(159, 159, 159));
draw_rectangle(xOffset, yOffset+buttonHeight, xOffset+vItems*entityButtonSize, yOffset+buttonHeight+ceil(entityButtonCount/vItems)*entityButtonSize, false);
draw_set_color(make_color_rgb(63, 63, 63));
draw_rectangle(xOffset, yOffset+buttonHeight, xOffset+vItems*entityButtonSize, yOffset+buttonHeight+ceil(entityButtonCount/vItems)*entityButtonSize, true);

// Buttons
for(j=0; j&lt;entityButtonCount/vItems; j+=1) {
    for(i=0; i&lt;vItems &amp;&amp; j*vItems + i &lt; entityButtonCount; i+=1) {
        draw_sprite(entityButtons[j*vItems+i, SPRITE], entityButtons[j*vItems+i, IMAGE] + (selected != j*vItems+i), xOffset+i*entityButtonSize, yOffset+buttonHeight+j*entityButtonSize);
    }
}

// Tooltip
if (tooltipIdx &gt;= 0) {
    if (is_string(entityButtons[tooltipIdx, TOOLTIP])) {
        var x2, y2;
        if (mouse_x-view_xview[0]+string_width(entityButtons[tooltipIdx, TOOLTIP])+14 &gt; view_wview[0]) x2 = mouse_x - string_width(entityButtons[tooltipIdx, TOOLTIP]) - 12;
        else x2 = mouse_x+12;
        y2 = round(mouse_y-string_height(entityButtons[tooltipIdx, TOOLTIP])/2);    // round to prevent gm from squishing the text
        draw_rectangle(x2-2, y2-2, x2+string_width(entityButtons[tooltipIdx, TOOLTIP])+2, y2+string_height(entityButtons[tooltipIdx, TOOLTIP])+2, false);
        draw_set_color(c_white);
        draw_text(x2, y2, entityButtons[tooltipIdx, TOOLTIP]);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="27">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!instance_exists(MenuController) &amp;&amp; visible) instance_create(0,0,BuilderMenuController);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
